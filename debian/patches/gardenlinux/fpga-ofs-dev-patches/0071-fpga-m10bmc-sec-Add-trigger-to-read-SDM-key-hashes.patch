From 6ab4162465ad7cffe81be109d997e45a80d16ba6 Mon Sep 17 00:00:00 2001
From: Tianfei Zhang <tianfei.zhang@intel.com>
Date: Fri, 8 Jul 2022 22:36:14 +0800
Subject: [PATCH 71/93] fpga: m10bmc-sec: Add trigger to read SDM key hashes

Trigger the reading of the SDM key hashes to BMC registers during driver
initialization and check for completion of the read before completing
a sysfs read for the same data. The SDM trigger is executed in a
worker thread and flush_work() is used to guarantee that the work
has completed before responding to a sysfs read of the data.

Signed-off-by: Tianfei Zhang <tianfei.zhang@intel.com>
Signed-off-by: Russ Weight <russell.h.weight@intel.com>
---
 drivers/fpga/intel-m10-bmc-sec-update.c | 79 ++++++++++++++++++++++++-
 include/linux/mfd/intel-m10-bmc.h       | 12 ++++
 2 files changed, 90 insertions(+), 1 deletion(-)

diff --git a/drivers/fpga/intel-m10-bmc-sec-update.c b/drivers/fpga/intel-m10-bmc-sec-update.c
index 5492c1e68cab..38649b6a5e64 100644
--- a/drivers/fpga/intel-m10-bmc-sec-update.c
+++ b/drivers/fpga/intel-m10-bmc-sec-update.c
@@ -56,6 +56,7 @@ struct m10bmc_sec {
 	struct image_load *image_load;		/* terminated with { } member */
 	enum fpga_sec_type type;
 	const struct fpga_power_on *poc;	/* power on image configuration */
+	struct work_struct work;
 };
 
 struct image_load {
@@ -535,6 +536,71 @@ DEVICE_ATTR_SEC_REH_RO(pr);
 
 #define SDM_ROOT_HASH_REG_NUM 12
 
+static int sdm_check_config_status(struct m10bmc_sec *sec)
+{
+	struct intel_m10bmc *m10bmc = sec->m10bmc;
+	u32 val;
+	int ret;
+
+	ret = m10bmc_sys_read(m10bmc, M10BMC_PMCI_SDM_CTRL, &val);
+	if (ret)
+		return -EIO;
+
+	return FIELD_GET(SDM_CMD_DONE, val);
+}
+
+static int sdm_trigger_prov_data(struct m10bmc_sec *sec)
+{
+	struct intel_m10bmc *m10bmc = sec->m10bmc;
+	u32 cmd = 0;
+	int ret;
+
+	ret = m10bmc_sys_update_bits(m10bmc,
+				     M10BMC_PMCI_SDM_CTRL,
+				     SDM_CMD_SELECT,
+				     FIELD_PREP(SDM_CMD_SELECT, SDM_CMD_PROV_DATA));
+	if (ret)
+		return ret;
+
+	ret = m10bmc_sys_update_bits(m10bmc,
+				     M10BMC_PMCI_SDM_CTRL,
+				     SDM_CMD_TRIGGER, SDM_CMD_TRIGGER);
+	if (ret)
+		return ret;
+
+	ret = regmap_read_poll_timeout(m10bmc->regmap,
+				       m10bmc_base(sec->m10bmc) + M10BMC_PMCI_SDM_CTRL,
+				       cmd, sdm_status(cmd) == SDM_CMD_STATUS_IDLE,
+				       NIOS_HANDSHAKE_INTERVAL_US,
+				       NIOS_HANDSHAKE_TIMEOUT_US);
+	if (ret) {
+		dev_err(sec->dev, "Error polling SDM CTRL register: %d\n", ret);
+		return ret;
+	} else if (sdm_error(cmd) != SDM_CMD_SUCC) {
+		dev_err(sec->dev, "SDM trigger failure: %ld\n", sdm_error(cmd));
+		return -EIO;
+	}
+
+	ret = regmap_read_poll_timeout(m10bmc->regmap,
+				       m10bmc_base(sec->m10bmc) + M10BMC_PMCI_SDM_CTRL,
+				       cmd, (cmd & SDM_CMD_DONE),
+				       NIOS_HANDSHAKE_INTERVAL_US,
+				       2 * NIOS_HANDSHAKE_TIMEOUT_US);
+	if (ret) {
+		dev_err(sec->dev, "Error polling for SDM operation done: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static void sdm_work(struct work_struct *work)
+{
+	struct m10bmc_sec *sec = container_of(work, struct m10bmc_sec,
+						work);
+	sdm_trigger_prov_data(sec);
+}
+
 static ssize_t
 show_sdm_root_entry_hash(struct device *dev, u32 start, char *buf)
 {
@@ -542,6 +608,11 @@ show_sdm_root_entry_hash(struct device *dev, u32 start, char *buf)
 	int i, cnt, ret;
 	u32 key;
 
+	flush_work(&sec->work);
+
+	if (sdm_check_config_status(sec) <= 0)
+		return -EIO;
+
 	cnt = sprintf(buf, "0x");
 	for (i = 0; i < SDM_ROOT_HASH_REG_NUM; i++) {
 		ret = m10bmc_sys_read(sec->m10bmc,
@@ -1540,8 +1611,11 @@ static int m10bmc_sec_probe(struct platform_device *pdev)
 	else if (type == N6000BMC_SEC)
 		sec->image_load = pmci_image_load_hndlrs;
 
-	if (type == N6000BMC_SEC)
+	if (type == N6000BMC_SEC) {
 		sec->poc = &pmci_power_on_image;
+		INIT_WORK(&sec->work, sdm_work);
+		queue_work(system_long_wq, &sec->work);
+	}
 
 	if (type == N6000BMC_SEC && !sec->m10bmc->flash_ops) {
 		dev_err(sec->dev, "No flash-ops provided for security manager\n");
@@ -1578,6 +1652,9 @@ static int m10bmc_sec_remove(struct platform_device *pdev)
 {
 	struct m10bmc_sec *sec = dev_get_drvdata(&pdev->dev);
 
+	if (sec->type == N6000BMC_SEC)
+		flush_work(&sec->work);
+
 	firmware_upload_unregister(sec->fwl);
 	kfree(sec->fw_name);
 	xa_erase(&fw_upload_xa, sec->fw_name_id);
diff --git a/include/linux/mfd/intel-m10-bmc.h b/include/linux/mfd/intel-m10-bmc.h
index 7f29bbb41f21..c536addfa482 100644
--- a/include/linux/mfd/intel-m10-bmc.h
+++ b/include/linux/mfd/intel-m10-bmc.h
@@ -272,6 +272,18 @@ enum m10bmc_type {
 #define PMCI_SDM_PR_CNCL_REQ		 BIT(0)
 #define PMCI_SDM_PR_CNCL_ERROR		 GENMASK(18, 8)
 
+#define M10BMC_PMCI_SDM_CTRL 0x234
+#define SDM_CMD_TRIGGER        BIT(0)
+#define SDM_CMD_DONE           BIT(2)
+#define SDM_CMD_SELECT         GENMASK(11, 4)
+#define SDM_CMD_PROV_DATA      0x3
+#define SDM_CMD_STATUS         GENMASK(15, 12)
+#define sdm_status(cmd)	FIELD_GET(SDM_CMD_STATUS, cmd)
+#define SDM_CMD_STATUS_IDLE    0x0
+#define SDM_CMD_ERROR          GENMASK(23, 16)
+#define sdm_error(cmd)	FIELD_GET(SDM_CMD_ERROR, cmd)
+#define SDM_CMD_SUCC           0x0
+
 #define M10BMC_PMCI_SDM_PR_STS		0x820
 #define M10BMC_PMCI_CERT_PROG_STS	0x824
 #define M10BMC_PMCI_CERT_SPEC_STS	0x828
-- 
2.39.0

