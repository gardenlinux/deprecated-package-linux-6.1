From 440193ec2c6917b04338201d2f81e392030a67c6 Mon Sep 17 00:00:00 2001
From: Russ Weight <russell.h.weight@intel.com>
Date: Mon, 4 Oct 2021 16:02:24 -0700
Subject: [PATCH 67/93] fpga: m10bmc-sec: Expose SDM provisioning status

Provide a new read-only sysfs file, sdm_provision_status, to report the
N6000 SDM key provisioning status.

Signed-off-by: Russ Weight <russell.h.weight@intel.com>
---
 .../sysfs-driver-intel-m10-bmc-sec-update     |  8 ++
 drivers/fpga/intel-m10-bmc-sec-update.c       | 92 ++++++++++++++-----
 include/linux/mfd/intel-m10-bmc.h             | 45 +++++++--
 3 files changed, 116 insertions(+), 29 deletions(-)

diff --git a/Documentation/ABI/testing/sysfs-driver-intel-m10-bmc-sec-update b/Documentation/ABI/testing/sysfs-driver-intel-m10-bmc-sec-update
index ab8e90380e8d..e043ea4a6b79 100644
--- a/Documentation/ABI/testing/sysfs-driver-intel-m10-bmc-sec-update
+++ b/Documentation/ABI/testing/sysfs-driver-intel-m10-bmc-sec-update
@@ -60,6 +60,14 @@ Description:	Read only. Returns number of times the secure update
 		staging area has been flashed.
 		Format: "%u".
 
+What:		/sys/bus/platform/drivers/intel-m10bmc-sec-update/.../security/sdm_sr_provision_status
+Date:		November 2021
+KernelVersion:  5.16
+Contact:	Russ Weight <russell.h.weight@intel.com>
+Description:	Read-only. Read this file to determine the status of SDM
+		static region key provisioning.
+		Format: "0x%x".
+
 What:		/sys/bus/platform/drivers/intel-m10bmc-sec-update/.../control/available_images
 Date:		Nov 2021
 KernelVersion:  5.16
diff --git a/drivers/fpga/intel-m10-bmc-sec-update.c b/drivers/fpga/intel-m10-bmc-sec-update.c
index d6ffb33e2f80..0ed8e69a38ff 100644
--- a/drivers/fpga/intel-m10-bmc-sec-update.c
+++ b/drivers/fpga/intel-m10-bmc-sec-update.c
@@ -63,14 +63,49 @@ struct image_load {
 	int (*load_image)(struct m10bmc_sec *sec);
 };
 
+static int
+m10bmc_sec_status(struct m10bmc_sec *sec, u32 *status)
+{
+	u32 reg_offset, reg_value;
+	int ret;
+
+	reg_offset = (sec->type == N6000BMC_SEC) ?
+		auth_result_reg(sec->m10bmc) : doorbell_reg(sec->m10bmc);
+
+	ret = m10bmc_sys_read(sec->m10bmc, reg_offset, &reg_value);
+	if (ret)
+		return ret;
+
+	*status = rsu_stat(reg_value);
+
+	return 0;
+}
+
 static void log_error_regs(struct m10bmc_sec *sec, u32 doorbell)
 {
-	u32 auth_result;
+	u32 auth_result, status;
 
 	dev_err(sec->dev, "RSU error status: 0x%08x\n", doorbell);
 
 	if (!m10bmc_sys_read(sec->m10bmc, auth_result_reg(sec->m10bmc), &auth_result))
 		dev_err(sec->dev, "RSU auth result: 0x%08x\n", auth_result);
+
+	if (m10bmc_sec_status(sec, &status))
+		return;
+
+	if (status == RSU_STAT_SDM_PR_FAILED) {
+		if (!m10bmc_sys_read(sec->m10bmc, M10BMC_PMCI_SDM_PR_STS, &status))
+			dev_err(sec->dev, "SDM Key Program Status: 0x%08x\n",
+				status);
+	} else if (status == RSU_STAT_SDM_SR_SDM_FAILED ||
+		   status == RSU_STAT_SDM_KEY_FAILED) {
+		if (!m10bmc_sys_read(sec->m10bmc, M10BMC_PMCI_CERT_PROG_STS, &status))
+			dev_err(sec->dev, "Certificate Program Status: 0x%08x\n",
+				status);
+		if (!m10bmc_sys_read(sec->m10bmc, M10BMC_PMCI_CERT_SPEC_STS, &status))
+			dev_err(sec->dev, "Certificate Specific Status: 0x%08x\n",
+				status);
+	}
 }
 
 static int m10bmc_sec_bmc_image_load(struct m10bmc_sec *sec,
@@ -538,6 +573,36 @@ static ssize_t flash_count_show(struct device *dev,
 }
 static DEVICE_ATTR_RO(flash_count);
 
+static ssize_t
+sdm_sr_provision_status_show(struct device *dev,
+			     struct device_attribute *attr, char *buf)
+{
+	struct m10bmc_sec *sec = dev_get_drvdata(dev);
+	u32 status;
+	int ret;
+
+	ret = m10bmc_sys_read(sec->m10bmc, m10bmc_base(sec->m10bmc) +
+			      M10BMC_PMCI_SDM_CTRL_STS, &status);
+	if (ret)
+		return ret;
+
+	return sysfs_emit(buf, "0x%x\n",
+			  (unsigned int)FIELD_GET(PMCI_SDM_PGM_ERROR, status));
+}
+static DEVICE_ATTR_RO(sdm_sr_provision_status);
+
+static umode_t
+m10bmc_security_is_visible(struct kobject *kobj, struct attribute *attr, int n)
+{
+	struct m10bmc_sec *sec = dev_get_drvdata(kobj_to_dev(kobj));
+
+	if (sec->type != N6000BMC_SEC &&
+	    attr == &dev_attr_sdm_sr_provision_status.attr)
+		return 0;
+
+	return attr->mode;
+}
+
 static struct attribute *m10bmc_security_attrs[] = {
 	&dev_attr_flash_count.attr,
 	&dev_attr_bmc_root_entry_hash.attr,
@@ -546,12 +611,14 @@ static struct attribute *m10bmc_security_attrs[] = {
 	&dev_attr_sr_canceled_csks.attr,
 	&dev_attr_pr_canceled_csks.attr,
 	&dev_attr_bmc_canceled_csks.attr,
+	&dev_attr_sdm_sr_provision_status.attr,
 	NULL,
 };
 
 static struct attribute_group m10bmc_security_attr_group = {
 	.name = "security",
 	.attrs = m10bmc_security_attrs,
+	.is_visible = m10bmc_security_is_visible,
 };
 
 static enum fpga_image
@@ -792,8 +859,7 @@ static ssize_t image_load_store(struct device *dev,
 static DEVICE_ATTR_WO(image_load);
 
 static umode_t
-m10bmc_is_visible(struct kobject *kobj,
-		  struct attribute *attr, int n)
+m10bmc_image_is_visible(struct kobject *kobj, struct attribute *attr, int n)
 {
 	struct m10bmc_sec *sec = dev_get_drvdata(kobj_to_dev(kobj));
 
@@ -818,7 +884,7 @@ static struct attribute *m10bmc_control_attrs[] = {
 static struct attribute_group m10bmc_control_attr_group = {
 	.name = "control",
 	.attrs = m10bmc_control_attrs,
-	.is_visible = m10bmc_is_visible,
+	.is_visible = m10bmc_image_is_visible,
 };
 
 static const struct attribute_group *m10bmc_sec_attr_groups[] = {
@@ -849,24 +915,6 @@ static bool rsu_progress_busy(u32 progress)
 		progress == RSU_PROG_PROGRAM_KEY_HASH);
 }
 
-static int
-m10bmc_sec_status(struct m10bmc_sec *sec, u32 *status)
-{
-	u32 reg_offset, reg_value;
-	int ret;
-
-	reg_offset = (sec->type == N6000BMC_SEC) ?
-		auth_result_reg(sec->m10bmc) : doorbell_reg(sec->m10bmc);
-
-	ret = m10bmc_sys_read(sec->m10bmc, reg_offset, &reg_value);
-	if (ret)
-		return ret;
-
-	*status = rsu_stat(reg_value);
-
-	return 0;
-}
-
 static int
 m10bmc_sec_progress_status(struct m10bmc_sec *sec, u32 *doorbell,
 			   u32 *progress, u32 *status)
diff --git a/include/linux/mfd/intel-m10-bmc.h b/include/linux/mfd/intel-m10-bmc.h
index 22f4e82edbe0..94138aace931 100644
--- a/include/linux/mfd/intel-m10-bmc.h
+++ b/include/linux/mfd/intel-m10-bmc.h
@@ -127,13 +127,39 @@ enum m10bmc_type {
 #define RSU_STAT_NON_INC		0x6
 #define RSU_STAT_ERASE_FAIL		0x7
 #define RSU_STAT_WEAROUT		0x8
-#define RSU_STAT_NIOS_OK		0x80
-#define RSU_STAT_USER_OK		0x81
-#define RSU_STAT_FACTORY_OK		0x82
-#define RSU_STAT_USER_FAIL		0x83
-#define RSU_STAT_FACTORY_FAIL		0x84
-#define RSU_STAT_NIOS_FLASH_ERR		0x85
-#define RSU_STAT_FPGA_FLASH_ERR		0x86
+#define RSU_STAT_PMCI_SS_FAIL           0x9
+#define RSU_STAT_FLASH_CMD              0xa
+#define RSU_STAT_FACTORY_UNVERITY       0xb
+#define RSU_STAT_FACTORY_ACTIVE         0xc
+#define RSU_STAT_POWER_DOWN             0xd
+#define RSU_STAT_CANCELLATION           0xe
+#define RSU_STAT_HASH                   0xf
+#define RSU_STAT_FLASH_ACCESS           0x10
+#define RSU_STAT_SDM_PR_CERT	        0x20
+#define RSU_STAT_SDM_PR_NIOS_BUSY	0x21
+#define RSU_STAT_SDM_PR_TIMEOUT	        0x22
+#define RSU_STAT_SDM_PR_FAILED		0x23
+#define RSU_STAT_SDM_PR_MISMATCH	0x24
+#define RSU_STAT_SDM_PR_FLUSH   	0x25
+#define RSU_STAT_SDM_SR_CERT	        0x30
+#define RSU_STAT_SDM_SR_NIOS_BUSY	0x31
+#define RSU_STAT_SDM_SR_TIMEOUT	        0x32
+#define RSU_STAT_SDM_SR_SDM_FAILED	0x33
+#define RSU_STAT_SDM_SR_MISMATCH	0x34
+#define RSU_STAT_SDM_SR_FLUSH   	0x35
+#define RSU_STAT_SDM_KEY_CERT	        0x40
+#define RSU_STAT_SDM_KEY_NIOS_BUSY	0x41
+#define RSU_STAT_SDM_KEY_TIMEOUT	0x42
+#define RSU_STAT_SDM_KEY_FAILED		0x43
+#define RSU_STAT_SDM_KEY_MISMATCH	0x44
+#define RSU_STAT_SDM_KEY_FLUSH   	0x45
+#define RSU_STAT_NIOS_OK                0x80
+#define RSU_STAT_USER_OK                0x81
+#define RSU_STAT_FACTORY_OK             0x82
+#define RSU_STAT_USER_FAIL              0x83
+#define RSU_STAT_FACTORY_FAIL           0x84
+#define RSU_STAT_NIOS_FLASH_ERR         0x85
+#define RSU_STAT_FPGA_FLASH_ERR	        0x86
 
 #define HOST_STATUS_IDLE		0x0
 #define HOST_STATUS_WRITE_DONE		0x1
@@ -232,6 +258,11 @@ enum m10bmc_type {
 
 #define M10BMC_PMCI_SDM_CTRL_STS 0x230
 #define PMCI_SDM_IMG_REQ	BIT(0)
+#define PMCI_SDM_PGM_ERROR	GENMASK(23, 16)
+
+#define M10BMC_PMCI_SDM_PR_STS		0x820
+#define M10BMC_PMCI_CERT_PROG_STS	0x824
+#define M10BMC_PMCI_CERT_SPEC_STS	0x828
 
 #define PMCI_ERROR_LOG_ADDR  0x7fb0000
 #define PMCI_ERROR_LOG_SIZE  0x40000
-- 
2.39.0

