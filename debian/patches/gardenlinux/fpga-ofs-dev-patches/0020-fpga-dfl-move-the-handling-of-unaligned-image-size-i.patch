From d64e6a453c56ef77028b2860c903666e35fadcce Mon Sep 17 00:00:00 2001
From: Xu Yilun <yilun.xu@intel.com>
Date: Fri, 18 Jun 2021 15:58:25 +0800
Subject: [PATCH 20/93] fpga: dfl: move the handling of unaligned image size in
 fpga mgr ops

This is to better support the fpga APIs. Callers then don't have to
care about the specific image size alignment of the DFL PR engine.

Signed-off-by: Xu Yilun <yilun.xu@intel.com>
Signed-off-by: Jeff Boyd <jeffrey.boyd@intel.com>
---
 drivers/fpga/dfl-fme-mgr.c | 12 +++++-------
 drivers/fpga/dfl-fme-pr.c  | 12 +++---------
 2 files changed, 8 insertions(+), 16 deletions(-)

diff --git a/drivers/fpga/dfl-fme-mgr.c b/drivers/fpga/dfl-fme-mgr.c
index 65bac16e4bd8..4a12a988ab38 100644
--- a/drivers/fpga/dfl-fme-mgr.c
+++ b/drivers/fpga/dfl-fme-mgr.c
@@ -180,6 +180,7 @@ static int fme_mgr_write(struct fpga_manager *mgr,
 	void __iomem *fme_pr = priv->ioaddr;
 	u64 pr_ctrl, pr_status, pr_data;
 	int delay = 0, pr_credit;
+	size_t chunk_size;
 
 	dev_dbg(dev, "start request\n");
 
@@ -210,17 +211,14 @@ static int fme_mgr_write(struct fpga_manager *mgr,
 			pr_credit = FIELD_GET(FME_PR_STS_PR_CREDIT, pr_status);
 		}
 
-		if (count < 4) {
-			dev_err(dev, "Invalid PR bitstream size\n");
-			return -EINVAL;
-		}
+		chunk_size = min_t(size_t, count, 4);
 
 		pr_data = 0;
-		memcpy(&pr_data, buf, 4);
+		memcpy(&pr_data, buf, chunk_size);
 		pr_data_write(pr_data, fme_pr + FME_PR_DATA);
 
-		buf += 4;
-		count -= 4;
+		buf += chunk_size;
+		count -= chunk_size;
 		pr_credit--;
 	}
 
diff --git a/drivers/fpga/dfl-fme-pr.c b/drivers/fpga/dfl-fme-pr.c
index fe35d7b85f28..d42d3f54b700 100644
--- a/drivers/fpga/dfl-fme-pr.c
+++ b/drivers/fpga/dfl-fme-pr.c
@@ -74,7 +74,6 @@ static int fme_pr(struct platform_device *pdev, unsigned long arg)
 	struct dfl_fme *fme;
 	unsigned long minsz;
 	void *buf = NULL;
-	size_t length;
 	int ret = 0;
 	u64 v;
 
@@ -83,7 +82,7 @@ static int fme_pr(struct platform_device *pdev, unsigned long arg)
 	if (copy_from_user(&port_pr, argp, minsz))
 		return -EFAULT;
 
-	if (port_pr.argsz < minsz || port_pr.flags)
+	if (port_pr.argsz < minsz || port_pr.flags || !port_pr.buffer_size)
 		return -EINVAL;
 
 	/* get fme header region */
@@ -98,13 +97,8 @@ static int fme_pr(struct platform_device *pdev, unsigned long arg)
 
 	if (port_pr.buffer_size == 0)
 		return -EINVAL;
-	/*
-	 * align PR buffer per PR bandwidth, as HW ignores the extra padding
-	 * data automatically.
-	 */
-	length = ALIGN(port_pr.buffer_size, 4);
 
-	buf = vmalloc(length);
+	buf = vmalloc(port_pr.buffer_size);
 	if (!buf)
 		return -ENOMEM;
 
@@ -141,7 +135,7 @@ static int fme_pr(struct platform_device *pdev, unsigned long arg)
 	fpga_image_info_free(region->info);
 
 	info->buf = buf;
-	info->count = length;
+	info->count = port_pr.buffer_size;
 	info->region_id = port_pr.port_id;
 	region->info = info;
 
-- 
2.39.0

