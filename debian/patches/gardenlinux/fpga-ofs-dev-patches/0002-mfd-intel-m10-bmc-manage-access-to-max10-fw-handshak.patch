From b5821d0e930761ba34277d1093f8063d306eb4d5 Mon Sep 17 00:00:00 2001
From: Xu Yilun <yilun.xu@intel.com>
Date: Thu, 4 Mar 2021 18:08:13 -0800
Subject: [PATCH 02/93] mfd: intel-m10-bmc: manage access to max10 fw handshake
 registers

Manage access to NIOS FW handshakes by using a rw semaphore
to prevent accesses to handshake registers during a secure
update.

Signed-off-by: Russ Weight <russell.h.weight@intel.com>
Signed-off-by: Xu Yilun <yilun.xu@intel.com>
---
 drivers/mfd/intel-m10-bmc.c       | 104 ++++++++++++++++++++++++++++++
 include/linux/mfd/intel-m10-bmc.h |  44 +++++++++++--
 2 files changed, 141 insertions(+), 7 deletions(-)

diff --git a/drivers/mfd/intel-m10-bmc.c b/drivers/mfd/intel-m10-bmc.c
index 7e3319e5b22f..af688b5c6dc6 100644
--- a/drivers/mfd/intel-m10-bmc.c
+++ b/drivers/mfd/intel-m10-bmc.c
@@ -24,16 +24,28 @@ static struct mfd_cell m10bmc_d5005_subdevs[] = {
 	{ .name = "d5005bmc-sec-update" }
 };
 
+static const struct regmap_range d5005_fw_handshake_regs[] = {
+	regmap_reg_range(M10BMC_D5005_TELEM_START, M10BMC_D5005_TELEM_END),
+};
+
 static struct mfd_cell m10bmc_pacn3000_subdevs[] = {
 	{ .name = "n3000bmc-hwmon" },
 	{ .name = "n3000bmc-retimer" },
 	{ .name = "n3000bmc-sec-update" },
 };
 
+static const struct regmap_range n3000_fw_handshake_regs[] = {
+	regmap_reg_range(M10BMC_N3000_TELEM_START, M10BMC_N3000_TELEM_END),
+};
+
 static struct mfd_cell m10bmc_n5010_subdevs[] = {
 	{ .name = "n5010bmc-hwmon" },
 };
 
+static const struct regmap_range n5010_fw_handshake_regs[] = {
+	regmap_reg_range(M10BMC_N5010_TELEM_START, M10BMC_N5010_TELEM_END),
+};
+
 static const struct regmap_range m10bmc_regmap_range[] = {
 	regmap_reg_range(M10BMC_LEGACY_BUILD_VER, M10BMC_LEGACY_BUILD_VER),
 	regmap_reg_range(M10BMC_SYS_BASE, M10BMC_SYS_END),
@@ -45,6 +57,88 @@ static const struct regmap_access_table m10bmc_access_table = {
 	.n_yes_ranges	= ARRAY_SIZE(m10bmc_regmap_range),
 };
 
+int m10bmc_fw_state_enter(struct intel_m10bmc *m10bmc,
+			  enum m10bmc_fw_state new_state)
+{
+	int ret = 0;
+
+	if (new_state == M10BMC_FW_STATE_NORMAL)
+		return -EINVAL;
+
+	down_write(&m10bmc->bmcfw_lock);
+
+	if (m10bmc->bmcfw_state == M10BMC_FW_STATE_NORMAL)
+		m10bmc->bmcfw_state = new_state;
+	else if (m10bmc->bmcfw_state != new_state)
+		ret = -EBUSY;
+
+	up_write(&m10bmc->bmcfw_lock);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(m10bmc_fw_state_enter);
+
+void m10bmc_fw_state_exit(struct intel_m10bmc *m10bmc)
+{
+	down_write(&m10bmc->bmcfw_lock);
+
+	m10bmc->bmcfw_state = M10BMC_FW_STATE_NORMAL;
+
+	up_write(&m10bmc->bmcfw_lock);
+}
+EXPORT_SYMBOL_GPL(m10bmc_fw_state_exit);
+
+static bool is_handshake_sys_reg(struct intel_m10bmc *m10bmc,
+				 unsigned int offset)
+{
+	return regmap_reg_in_ranges(offset, m10bmc->handshake_sys_reg_ranges,
+				    m10bmc->handshake_sys_reg_nranges);
+}
+
+int m10bmc_sys_read(struct intel_m10bmc *m10bmc, unsigned int offset,
+		    unsigned int *val)
+{
+	int ret;
+
+	if (!is_handshake_sys_reg(m10bmc, offset))
+		return m10bmc_raw_read(m10bmc, M10BMC_SYS_BASE + (offset), val);
+
+	down_read(&m10bmc->bmcfw_lock);
+
+	if (m10bmc->bmcfw_state == M10BMC_FW_STATE_SEC_UPDATE)
+		ret = -EBUSY;
+	else
+		ret = m10bmc_raw_read(m10bmc, M10BMC_SYS_BASE + (offset), val);
+
+	up_read(&m10bmc->bmcfw_lock);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(m10bmc_sys_read);
+
+int m10bmc_sys_update_bits(struct intel_m10bmc *m10bmc, unsigned int offset,
+			   unsigned int msk, unsigned int val)
+{
+	int ret;
+
+	if (!is_handshake_sys_reg(m10bmc, offset))
+		return regmap_update_bits(m10bmc->regmap,
+					  M10BMC_SYS_BASE + (offset), msk, val);
+
+	down_read(&m10bmc->bmcfw_lock);
+
+	if (m10bmc->bmcfw_state == M10BMC_FW_STATE_SEC_UPDATE)
+		ret = -EBUSY;
+	else
+		ret = regmap_update_bits(m10bmc->regmap,
+					 M10BMC_SYS_BASE + (offset), msk, val);
+
+	up_read(&m10bmc->bmcfw_lock);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(m10bmc_sys_update_bits);
+
 static struct regmap_config intel_m10bmc_regmap_config = {
 	.reg_bits = 32,
 	.val_bits = 32,
@@ -171,6 +265,7 @@ static int intel_m10_bmc_spi_probe(struct spi_device *spi)
 	if (!ddata)
 		return -ENOMEM;
 
+	init_rwsem(&ddata->bmcfw_lock);
 	ddata->dev = dev;
 
 	ddata->regmap =
@@ -193,14 +288,23 @@ static int intel_m10_bmc_spi_probe(struct spi_device *spi)
 	case M10_N3000:
 		cells = m10bmc_pacn3000_subdevs;
 		n_cell = ARRAY_SIZE(m10bmc_pacn3000_subdevs);
+		ddata->handshake_sys_reg_ranges = n3000_fw_handshake_regs;
+		ddata->handshake_sys_reg_nranges =
+			ARRAY_SIZE(n3000_fw_handshake_regs);
 		break;
 	case M10_D5005:
 		cells = m10bmc_d5005_subdevs;
 		n_cell = ARRAY_SIZE(m10bmc_d5005_subdevs);
+		ddata->handshake_sys_reg_ranges = d5005_fw_handshake_regs;
+		ddata->handshake_sys_reg_nranges =
+			ARRAY_SIZE(d5005_fw_handshake_regs);
 		break;
 	case M10_N5010:
 		cells = m10bmc_n5010_subdevs;
 		n_cell = ARRAY_SIZE(m10bmc_n5010_subdevs);
+		ddata->handshake_sys_reg_ranges = n5010_fw_handshake_regs;
+		ddata->handshake_sys_reg_nranges =
+			ARRAY_SIZE(n5010_fw_handshake_regs);
 		break;
 	default:
 		return -ENODEV;
diff --git a/include/linux/mfd/intel-m10-bmc.h b/include/linux/mfd/intel-m10-bmc.h
index f0044b14136e..d84ea226a18d 100644
--- a/include/linux/mfd/intel-m10-bmc.h
+++ b/include/linux/mfd/intel-m10-bmc.h
@@ -8,6 +8,7 @@
 #define __MFD_INTEL_M10_BMC_H
 
 #include <linux/regmap.h>
+#include <linux/rwsem.h>
 
 #define M10BMC_LEGACY_BUILD_VER		0x300468
 #define M10BMC_SYS_BASE			0x300800
@@ -36,6 +37,14 @@
 #define M10BMC_VER_PCB_INFO_MSK		GENMASK(31, 24)
 #define M10BMC_VER_LEGACY_INVALID	0xffffffff
 
+/* Telemetry registers */
+#define M10BMC_N3000_TELEM_START	0x100
+#define M10BMC_N3000_TELEM_END		0x250
+#define M10BMC_D5005_TELEM_START	0x100
+#define M10BMC_D5005_TELEM_END		0x300
+#define M10BMC_N5010_TELEM_START	0x100
+#define M10BMC_N5010_TELEM_END		0x250
+
 /* Secure update doorbell register, in system register region */
 #define M10BMC_DOORBELL			0x400
 
@@ -118,14 +127,27 @@
 /* Address of 4KB inverted bit vector containing staging area FLASH count */
 #define STAGING_FLASH_COUNT	0x17ffb000
 
+enum m10bmc_fw_state {
+	M10BMC_FW_STATE_NORMAL,
+	M10BMC_FW_STATE_SEC_UPDATE,
+};
+
 /**
  * struct intel_m10bmc - Intel MAX 10 BMC parent driver data structure
  * @dev: this device
  * @regmap: the regmap used to access registers by m10bmc itself
+ * @bmcfw_lock: read/write semaphore to BMC firmware running state
+ * @bmcfw_state: BMC firmware running state
+ * @handshake_sys_reg_ranges: array of register ranges for fw handshake regs
+ * @handshake_sys_reg_nranges: number of register ranges for fw handshake regs
  */
 struct intel_m10bmc {
 	struct device *dev;
 	struct regmap *regmap;
+	struct rw_semaphore bmcfw_lock;
+	enum m10bmc_fw_state bmcfw_state;
+	const struct regmap_range *handshake_sys_reg_ranges;
+	unsigned int handshake_sys_reg_nranges;
 };
 
 /*
@@ -133,6 +155,7 @@ struct intel_m10bmc {
  *
  * m10bmc_raw_read - read m10bmc register per addr
  * m10bmc_sys_read - read m10bmc system register per offset
+ * m10bmc_sys_update_bits - update m10bmc system register per offset
  */
 static inline int
 m10bmc_raw_read(struct intel_m10bmc *m10bmc, unsigned int addr,
@@ -148,15 +171,22 @@ m10bmc_raw_read(struct intel_m10bmc *m10bmc, unsigned int addr,
 	return ret;
 }
 
+int m10bmc_sys_read(struct intel_m10bmc *m10bmc, unsigned int offset,
+		    unsigned int *val);
+
+int m10bmc_sys_update_bits(struct intel_m10bmc *m10bmc, unsigned int offset,
+			   unsigned int msk, unsigned int val);
+
 /*
- * The base of the system registers could be configured by HW developers, and
- * in HW SPEC, the base is not added to the addresses of the system registers.
+ * Track the state of the firmware, as it is not available for
+ * register handshakes during secure updates.
  *
- * This macro helps to simplify the accessing of the system registers. And if
- * the base is reconfigured in HW, SW developers could simply change the
- * M10BMC_SYS_BASE accordingly.
+ * m10bmc_fw_state_enter - firmware is unavailable for handshakes
+ * m10bmc_fw_state_exit  - firmware is available for handshakes
  */
-#define m10bmc_sys_read(m10bmc, offset, val) \
-	m10bmc_raw_read(m10bmc, M10BMC_SYS_BASE + (offset), val)
+int m10bmc_fw_state_enter(struct intel_m10bmc *m10bmc,
+			  enum m10bmc_fw_state new_state);
+
+void m10bmc_fw_state_exit(struct intel_m10bmc *m10bmc);
 
 #endif /* __MFD_INTEL_M10_BMC_H */
-- 
2.39.0

