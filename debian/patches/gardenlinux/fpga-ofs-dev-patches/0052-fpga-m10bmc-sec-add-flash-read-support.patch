From e555c198211d75d367926a69e311431326e9c13c Mon Sep 17 00:00:00 2001
From: Russ Weight <russell.h.weight@intel.com>
Date: Mon, 8 Mar 2021 07:05:15 -0500
Subject: [PATCH 52/93] fpga: m10bmc-sec: add flash read support

Adding basic flash read support of PMCI-based FPGA in secure manager.

Introducing device specific operations flash_read to read flash for
secure manager driver.
---
 drivers/fpga/intel-m10-bmc-sec-update.c | 60 ++++++-----------
 drivers/mfd/intel-m10-bmc-core.c        | 89 ++++++++++++++++++++++++-
 drivers/mfd/intel-m10-bmc-pmci.c        |  9 +++
 include/linux/mfd/intel-m10-bmc.h       | 27 ++++++++
 4 files changed, 144 insertions(+), 41 deletions(-)

diff --git a/drivers/fpga/intel-m10-bmc-sec-update.c b/drivers/fpga/intel-m10-bmc-sec-update.c
index e9a8e2aaaa3a..f6c80da7d179 100644
--- a/drivers/fpga/intel-m10-bmc-sec-update.c
+++ b/drivers/fpga/intel-m10-bmc-sec-update.c
@@ -282,11 +282,15 @@ show_root_entry_hash(struct device *dev, u32 exp_magic,
 	struct m10bmc_sec *sec = dev_get_drvdata(dev);
 	int sha_num_bytes, i, ret, cnt = 0;
 	u8 hash[REH_SHA384_SIZE];
-	unsigned int stride;
 	u32 magic;
 
-	stride = regmap_get_reg_stride(sec->m10bmc->regmap);
-	ret = m10bmc_raw_read(sec->m10bmc, prog_addr, &magic);
+	if (sec->type == N6000BMC_SEC) {
+		ret = sec->m10bmc->ops.flash_read(sec->m10bmc, &magic,
+						  prog_addr, sizeof(u32));
+	} else {
+		ret = m10bmc_raw_read(sec->m10bmc, prog_addr, &magic);
+	}
+
 	if (ret)
 		return ret;
 
@@ -294,19 +298,17 @@ show_root_entry_hash(struct device *dev, u32 exp_magic,
 		return sysfs_emit(buf, "hash not programmed\n");
 
 	sha_num_bytes = FIELD_GET(REH_SHA_NUM_BYTES, magic) / 8;
-	if ((sha_num_bytes % stride) ||
-	    (sha_num_bytes != REH_SHA256_SIZE &&
-	     sha_num_bytes != REH_SHA384_SIZE))   {
+	if (sha_num_bytes != REH_SHA256_SIZE &&
+	    sha_num_bytes != REH_SHA384_SIZE) {
 		dev_err(sec->dev, "%s bad sha num bytes %d\n", __func__,
 			sha_num_bytes);
 		return -EINVAL;
 	}
 
-	ret = regmap_bulk_read(sec->m10bmc->regmap, reh_addr,
-			       hash, sha_num_bytes / stride);
+	ret = sec->m10bmc->ops.flash_read(sec->m10bmc, hash, reh_addr,
+					   sha_num_bytes);
 	if (ret) {
-		dev_err(dev, "failed to read root entry hash: %x cnt %x: %d\n",
-			reh_addr, sha_num_bytes / stride, ret);
+		dev_err(dev, "failed to read root entry hash\n");
 		return ret;
 	}
 
@@ -339,27 +341,16 @@ DEVICE_ATTR_SEC_REH_RO(pr);
 static ssize_t
 show_canceled_csk(struct device *dev, u32 addr, char *buf)
 {
-	unsigned int i, stride, size = CSK_32ARRAY_SIZE * sizeof(u32);
+	unsigned int i, size = CSK_32ARRAY_SIZE * sizeof(u32);
 	struct m10bmc_sec *sec = dev_get_drvdata(dev);
 	DECLARE_BITMAP(csk_map, CSK_BIT_LEN);
 	__le32 csk_le32[CSK_32ARRAY_SIZE];
 	u32 csk32[CSK_32ARRAY_SIZE];
 	int ret;
 
-	stride = regmap_get_reg_stride(sec->m10bmc->regmap);
-	if (size % stride) {
-		dev_err(sec->dev,
-			"CSK vector size (0x%x) not aligned to stride (0x%x)\n",
-			size, stride);
-		WARN_ON_ONCE(1);
-		return -EINVAL;
-	}
-
-	ret = regmap_bulk_read(sec->m10bmc->regmap, addr, csk_le32,
-			       size / stride);
+	ret = sec->m10bmc->ops.flash_read(sec->m10bmc, csk_le32, addr, size);
 	if (ret) {
-		dev_err(sec->dev, "failed to read CSK vector: %x cnt %x: %d\n",
-			addr, size / stride, ret);
+		dev_err(sec->dev, "failed to read CSK vector\n");
 		return ret;
 	}
 
@@ -394,32 +385,21 @@ static ssize_t flash_count_show(struct device *dev,
 				struct device_attribute *attr, char *buf)
 {
 	struct m10bmc_sec *sec = dev_get_drvdata(dev);
-	unsigned int stride, num_bits;
+	unsigned int num_bits;
 	u8 *flash_buf;
 	int cnt, ret;
 
-	stride = regmap_get_reg_stride(sec->m10bmc->regmap);
 	num_bits = FLASH_COUNT_SIZE * 8;
 
-	if (FLASH_COUNT_SIZE % stride) {
-		dev_err(sec->dev,
-			"FLASH_COUNT_SIZE (0x%x) not aligned to stride (0x%x)\n",
-			FLASH_COUNT_SIZE, stride);
-		WARN_ON_ONCE(1);
-		return -EINVAL;
-	}
-
 	flash_buf = kmalloc(FLASH_COUNT_SIZE, GFP_KERNEL);
 	if (!flash_buf)
 		return -ENOMEM;
 
-	ret = regmap_bulk_read(sec->m10bmc->regmap,
-			       rsu_update_counter(sec->m10bmc), flash_buf,
-			       FLASH_COUNT_SIZE / stride);
+	ret = sec->m10bmc->ops.flash_read(sec->m10bmc, flash_buf,
+					  rsu_update_counter(sec->m10bmc),
+					  FLASH_COUNT_SIZE);
 	if (ret) {
-		dev_err(sec->dev,
-			"failed to read flash count: %x cnt %x: %d\n",
-			STAGING_FLASH_COUNT, FLASH_COUNT_SIZE / stride, ret);
+		dev_err(sec->dev, "failed to read flash count\n");
 		goto exit_free;
 	}
 	cnt = num_bits - bitmap_weight((unsigned long *)flash_buf, num_bits);
diff --git a/drivers/mfd/intel-m10-bmc-core.c b/drivers/mfd/intel-m10-bmc-core.c
index 17d8fe66c4a3..d03661fa1b7a 100644
--- a/drivers/mfd/intel-m10-bmc-core.c
+++ b/drivers/mfd/intel-m10-bmc-core.c
@@ -93,6 +93,85 @@ static const struct regmap_range n5014_fw_handshake_regs[] = {
 	regmap_reg_range(M10BMC_N5010_TELEM_START, M10BMC_N5010_TELEM_END),
 };
 
+static int
+m10bmc_flash_read(struct intel_m10bmc *m10bmc, void *buf, u32 addr, u32 size)
+{
+	unsigned int stride = regmap_get_reg_stride(m10bmc->regmap);
+	int ret;
+
+	if (size % stride) {
+		dev_err(m10bmc->dev,
+			"%s: size (0x%x) not aligned to stride (0x%x)\n",
+			__func__, size, stride);
+		WARN_ON_ONCE(1);
+		return -EINVAL;
+	}
+
+	ret = regmap_bulk_read(m10bmc->regmap, addr, buf, size / stride);
+	if (ret)
+		dev_err(m10bmc->dev,
+			"failed to read flash block data: %x cnt %x: %d\n",
+			addr, size / stride, ret);
+	return ret;
+}
+
+static int
+m10bmc_pmci_set_flash_host_mux(struct intel_m10bmc *m10bmc, bool request)
+{
+	u32 ctrl;
+	int ret;
+
+	ret = regmap_update_bits(m10bmc->regmap, M10BMC_PMCI_FLASH_CTRL,
+				 FLASH_HOST_REQUEST,
+				 FIELD_PREP(FLASH_HOST_REQUEST, request));
+	if (ret)
+		return ret;
+
+	return regmap_read_poll_timeout(m10bmc->regmap,
+					M10BMC_PMCI_FLASH_CTRL, ctrl,
+					request ? (get_flash_mux(ctrl) == FLASH_MUX_HOST) :
+					(get_flash_mux(ctrl) != FLASH_MUX_HOST),
+					M10_FLASH_INT_US, M10_FLASH_TIMEOUT_US);
+}
+
+static int
+m10bmc_pmci_get_mux(struct intel_m10bmc *m10bmc)
+{
+	mutex_lock(&m10bmc->flash_ops->mux_lock);
+	return m10bmc_pmci_set_flash_host_mux(m10bmc, true);
+}
+
+static int
+m10bmc_pmci_put_mux(struct intel_m10bmc *m10bmc)
+{
+	int ret;
+
+	ret = m10bmc_pmci_set_flash_host_mux(m10bmc, false);
+	mutex_unlock(&m10bmc->flash_ops->mux_lock);
+	return ret;
+}
+
+static int
+m10bmc_pmci_flash_read(struct intel_m10bmc *m10bmc, void *buffer,
+		       u32 addr, u32 size)
+{
+	int ret;
+
+	ret = m10bmc_pmci_get_mux(m10bmc);
+	if (ret)
+		goto read_fail;
+
+	ret = m10bmc->flash_ops->read_blk(m10bmc, buffer, addr, size);
+	if (ret)
+		goto read_fail;
+
+	return m10bmc_pmci_put_mux(m10bmc);
+
+read_fail:
+	m10bmc_pmci_put_mux(m10bmc);
+	return ret;
+}
+
 int m10bmc_fw_state_enter(struct intel_m10bmc *m10bmc,
 			  enum m10bmc_fw_state new_state)
 {
@@ -308,12 +387,20 @@ int m10bmc_dev_init(struct intel_m10bmc *m10bmc)
 	init_rwsem(&m10bmc->bmcfw_lock);
 	dev_set_drvdata(m10bmc->dev, m10bmc);
 
-	if (type == M10_N3000 || type == M10_D5005 || type == M10_N5010) {
+	if (m10bmc->type == M10_N6000) {
+		if (!m10bmc->flash_ops) {
+			dev_err(m10bmc->dev,
+				"No flash-ops provided\n");
+			return -EINVAL;
+		}
+		m10bmc->ops.flash_read = m10bmc_pmci_flash_read;
+	} else {
 		ret = check_m10bmc_version(m10bmc);
 		if (ret) {
 			dev_err(m10bmc->dev, "Failed to identify m10bmc hardware\n");
 			return ret;
 		}
+		m10bmc->ops.flash_read = m10bmc_flash_read;
 	}
 
 	switch (type) {
diff --git a/drivers/mfd/intel-m10-bmc-pmci.c b/drivers/mfd/intel-m10-bmc-pmci.c
index 1c4100898577..2c553c546c18 100644
--- a/drivers/mfd/intel-m10-bmc-pmci.c
+++ b/drivers/mfd/intel-m10-bmc-pmci.c
@@ -171,6 +171,7 @@ static int pmci_probe(struct dfl_device *ddev)
 
 	pmci_flash_ops->read_blk = pmci_flash_bulk_read;
 	pmci_flash_ops->write_blk = pmci_flash_bulk_write;
+	mutex_init(&pmci_flash_ops->mux_lock);
 
 	pmci->m10bmc.dev = dev;
 	pmci->dev = dev;
@@ -191,6 +192,13 @@ static int pmci_probe(struct dfl_device *ddev)
 	return m10bmc_dev_init(&pmci->m10bmc);
 }
 
+static void pmci_remove(struct dfl_device *ddev)
+{
+	struct intel_m10bmc *m10bmc = dev_get_drvdata(&ddev->dev);
+
+	mutex_destroy(&m10bmc->flash_ops->mux_lock);
+}
+
 #define FME_FEATURE_ID_PMCI_BMC	0x12
 
 static const struct dfl_device_id pmci_ids[] = {
@@ -206,6 +214,7 @@ static struct dfl_driver pmci_driver = {
 	},
 	.id_table = pmci_ids,
 	.probe    = pmci_probe,
+	.remove   = pmci_remove,
 };
 
 module_dfl_driver(pmci_driver);
diff --git a/include/linux/mfd/intel-m10-bmc.h b/include/linux/mfd/intel-m10-bmc.h
index 2c5bad471899..f3c342a79fb0 100644
--- a/include/linux/mfd/intel-m10-bmc.h
+++ b/include/linux/mfd/intel-m10-bmc.h
@@ -182,6 +182,20 @@ enum m10bmc_type {
 #define M10BMC_PMCI_MAC_LOW    0x20
 #define M10BMC_PMCI_MAC_HIGH    0x24
 
+#define M10BMC_PMCI_FLASH_CTRL 0x1d0
+#define FLASH_MUX_SELECTION GENMASK(2, 0)
+#define FLASH_MUX_IDLE 0
+#define FLASH_MUX_NIOS 1
+#define FLASH_MUX_HOST 2
+#define FLASH_MUX_PFL  4
+#define get_flash_mux(mux)      FIELD_GET(FLASH_MUX_SELECTION, mux)
+
+#define FLASH_NIOS_REQUEST BIT(4)
+#define FLASH_HOST_REQUEST BIT(5)
+
+#define M10_FLASH_INT_US       1
+#define M10_FLASH_TIMEOUT_US   10000
+
 /* Addresses for security related data in FLASH */
 #define PMCI_BMC_REH_ADDR 0x7ffc004
 #define PMCI_BMC_PROG_ADDR 0x7ffc000
@@ -238,10 +252,21 @@ struct m10bmc_csr {
  * struct fpga_flash_ops - device specific operations for flash R/W
  * @write_blk: write a block of data to flash
  * @read_blk: read a block of data from flash
+ * @mux_lock: Prevent concurrent flash burst reads
  */
 struct fpga_flash_ops {
 	int (*write_blk)(struct intel_m10bmc *m10bmc, void *buf, u32 size);
 	int (*read_blk)(struct intel_m10bmc *m10bmc, void *buf, u32 addr, u32 size);
+	struct mutex mux_lock;	/* Prevent concurrent flash burst reads */
+};
+
+/**
+ * struct m10bmc_ops - device specific operations
+ * @flash_read: read a block of data from flash
+ */
+struct m10bmc_ops {
+	int (*flash_read)(struct intel_m10bmc *m10bmc, void *buf,
+			  u32 addr, u32 size);
 };
 
 /**
@@ -255,6 +280,7 @@ struct fpga_flash_ops {
  * @handshake_sys_reg_nranges: number of register ranges for fw handshake regs
  * @csr: the register definition of MAX10 BMC
  * @flash_ops: optional device specific operations for flash R/W
+ * @ops: device specific operations
  */
 struct intel_m10bmc {
 	struct device *dev;
@@ -266,6 +292,7 @@ struct intel_m10bmc {
 	unsigned int handshake_sys_reg_nranges;
 	const struct m10bmc_csr *csr;
 	struct fpga_flash_ops *flash_ops;
+	struct m10bmc_ops ops;
 };
 
 /*
-- 
2.39.0

