From 183b6bea6221d205dd229cf5d89777abd6c31008 Mon Sep 17 00:00:00 2001
From: Tianfei zhang <tianfei.zhang@intel.com>
Date: Mon, 8 Mar 2021 07:05:11 -0500
Subject: [PATCH 50/93] mfd: pmci: add flash ops

Introducing fpga_flash_ops for read/write the flash for FPGA.
1. write_blk: write the data into staging area in MAX10 BMC
2. read_blk: read a block data from flash
---
 drivers/mfd/intel-m10-bmc-pmci.c  | 127 ++++++++++++++++++++++++++++++
 include/linux/mfd/intel-m10-bmc.h |  14 ++++
 2 files changed, 141 insertions(+)

diff --git a/drivers/mfd/intel-m10-bmc-pmci.c b/drivers/mfd/intel-m10-bmc-pmci.c
index e45c498efba8..1c4100898577 100644
--- a/drivers/mfd/intel-m10-bmc-pmci.c
+++ b/drivers/mfd/intel-m10-bmc-pmci.c
@@ -6,6 +6,7 @@
  *
  */
 
+#include <linux/bitfield.h>
 #include <linux/dfl.h>
 #include <linux/mfd/intel-m10-bmc.h>
 #include <linux/module.h>
@@ -13,12 +14,129 @@
 
 #define M10BMC_PMCI_INDIRECT_BASE 0x400
 
+#define PMCI_FLASH_CTRL 0x40
+#define PMCI_FLASH_WR_MODE BIT(0)
+#define PMCI_FLASH_RD_MODE BIT(1)
+#define PMCI_FLASH_BUSY    BIT(2)
+#define PMCI_FLASH_FIFO_SPACE GENMASK(13, 4)
+#define PMCI_FLASH_READ_COUNT GENMASK(25, 16)
+
+#define PMCI_FLASH_INT_US       1
+#define PMCI_FLASH_TIMEOUT_US   10000
+
+#define PMCI_FLASH_ADDR 0x44
+#define PMCI_FLASH_FIFO 0x800
+#define PMCI_READ_BLOCK_SIZE 0x800
+#define PMCI_FIFO_MAX_BYTES 0x800
+#define PMCI_FIFO_MAX_WORDS (PMCI_FIFO_MAX_BYTES / 4)
+
 struct pmci_device {
 	void __iomem *base;
 	struct device *dev;
 	struct intel_m10bmc m10bmc;
 };
 
+static void pmci_write_fifo(void __iomem *base, char *buf, size_t count)
+{
+       int i;
+       u32 val;
+
+       for (i = 0; i < count/4 ; i++) {
+               val = *(u32 *)(buf + i * 4);
+	       writel(val, base);
+       }
+}
+
+static void pmci_read_fifo(void __iomem *base, char *buf, size_t count)
+{
+       int i;
+       u32 val;
+
+       for (i = 0; i < count/4; i++) {
+               val = readl(base);
+               *(u32 *)(buf + i * 4) = val;
+       }
+}
+
+static u32
+pmci_get_write_space(struct pmci_device *pmci, u32 size)
+{
+	u32 count, val;
+	int ret;
+
+	ret = read_poll_timeout(readl, val,
+				FIELD_GET(PMCI_FLASH_FIFO_SPACE, val) ==
+				PMCI_FIFO_MAX_WORDS,
+				PMCI_FLASH_INT_US, PMCI_FLASH_TIMEOUT_US,
+				false, pmci->base + PMCI_FLASH_CTRL);
+	if (ret == -ETIMEDOUT)
+		return 0;
+
+	count = FIELD_GET(PMCI_FLASH_FIFO_SPACE, val) * 4;
+
+	return (size > count) ? count : size;
+}
+
+static int
+pmci_flash_bulk_write(struct intel_m10bmc *m10bmc, void *buf, u32 size)
+{
+	struct pmci_device *pmci = container_of(m10bmc, struct pmci_device, m10bmc);
+	u32 blk_size, n_offset = 0;
+
+	while (size) {
+		blk_size = pmci_get_write_space(pmci, size);
+		if (blk_size == 0) {
+			dev_err(pmci->dev, "get FIFO available size fail\n");
+			return -EIO;
+		}
+		size -= blk_size;
+		pmci_write_fifo(pmci->base + PMCI_FLASH_FIFO, buf + n_offset, blk_size);
+		n_offset += blk_size;
+	}
+
+	return 0;
+}
+
+static int
+pmci_flash_bulk_read(struct intel_m10bmc *m10bmc, void *buf,
+		     u32 addr, u32 size)
+{
+	struct pmci_device *pmci = container_of(m10bmc, struct pmci_device, m10bmc);
+	u32 blk_size, offset = 0, val;
+	int ret;
+
+	if (!IS_ALIGNED(addr, 4))
+		return -EINVAL;
+
+	while (size) {
+		blk_size = min_t(u32, size, PMCI_READ_BLOCK_SIZE);
+
+		writel(addr + offset, pmci->base + PMCI_FLASH_ADDR);
+
+		writel(FIELD_PREP(PMCI_FLASH_READ_COUNT, blk_size / 4)
+				| PMCI_FLASH_RD_MODE,
+			pmci->base + PMCI_FLASH_CTRL);
+
+		ret = readl_poll_timeout((pmci->base + PMCI_FLASH_CTRL), val,
+					 !(val & PMCI_FLASH_BUSY),
+					 PMCI_FLASH_INT_US, PMCI_FLASH_TIMEOUT_US);
+		if (ret) {
+			dev_err(pmci->dev, "%s timed out on reading flash 0x%xn",
+				__func__, val);
+			return ret;
+		}
+
+		pmci_read_fifo(pmci->base + PMCI_FLASH_FIFO, buf + offset, blk_size);
+
+		size -= blk_size;
+		offset += blk_size;
+
+		writel(0, pmci->base + PMCI_FLASH_CTRL);
+	}
+
+	return 0;
+}
+
 static const struct regmap_range m10bmc_pmci_regmap_range[] = {
 	regmap_reg_range(M10BMC_PMCI_SYS_BASE, M10BMC_PMCI_SYS_END),
 };
@@ -39,6 +157,7 @@ static struct regmap_config m10bmc_pmci_regmap_config = {
 
 static int pmci_probe(struct dfl_device *ddev)
 {
+	struct fpga_flash_ops *pmci_flash_ops;
 	struct device *dev = &ddev->dev;
 	struct pmci_device *pmci;
 
@@ -46,9 +165,17 @@ static int pmci_probe(struct dfl_device *ddev)
 	if (!pmci)
 		return -ENOMEM;
 
+	pmci_flash_ops = devm_kzalloc(dev, sizeof(*pmci_flash_ops), GFP_KERNEL);
+	if (!pmci_flash_ops)
+		return -ENOMEM;
+
+	pmci_flash_ops->read_blk = pmci_flash_bulk_read;
+	pmci_flash_ops->write_blk = pmci_flash_bulk_write;
+
 	pmci->m10bmc.dev = dev;
 	pmci->dev = dev;
 	pmci->m10bmc.type = M10_N6000;
+	pmci->m10bmc.flash_ops = pmci_flash_ops;
 
 	pmci->base = devm_ioremap_resource(dev, &ddev->mmio_res);
 	if (IS_ERR(pmci->base))
diff --git a/include/linux/mfd/intel-m10-bmc.h b/include/linux/mfd/intel-m10-bmc.h
index 8da00b03359f..2c5bad471899 100644
--- a/include/linux/mfd/intel-m10-bmc.h
+++ b/include/linux/mfd/intel-m10-bmc.h
@@ -11,6 +11,8 @@
 #include <linux/regmap.h>
 #include <linux/rwsem.h>
 
+struct intel_m10bmc;
+
 /* Supported MAX10 BMC types */
 enum m10bmc_type {
 	M10_N3000,
@@ -232,6 +234,16 @@ struct m10bmc_csr {
 	unsigned int rsu_update_counter;
 };
 
+/**
+ * struct fpga_flash_ops - device specific operations for flash R/W
+ * @write_blk: write a block of data to flash
+ * @read_blk: read a block of data from flash
+ */
+struct fpga_flash_ops {
+	int (*write_blk)(struct intel_m10bmc *m10bmc, void *buf, u32 size);
+	int (*read_blk)(struct intel_m10bmc *m10bmc, void *buf, u32 addr, u32 size);
+};
+
 /**
  * struct intel_m10bmc - Intel MAX 10 BMC parent driver data structure
  * @dev: this device
@@ -242,6 +254,7 @@ struct m10bmc_csr {
  * @handshake_sys_reg_ranges: array of register ranges for fw handshake regs
  * @handshake_sys_reg_nranges: number of register ranges for fw handshake regs
  * @csr: the register definition of MAX10 BMC
+ * @flash_ops: optional device specific operations for flash R/W
  */
 struct intel_m10bmc {
 	struct device *dev;
@@ -252,6 +265,7 @@ struct intel_m10bmc {
 	const struct regmap_range *handshake_sys_reg_ranges;
 	unsigned int handshake_sys_reg_nranges;
 	const struct m10bmc_csr *csr;
+	struct fpga_flash_ops *flash_ops;
 };
 
 /*
-- 
2.39.0

